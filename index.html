<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PokéGrid 5×5</title>

  <!-- Preload critical data files -->
  <link rel="preload" href="data/dex_de.json" as="fetch" crossorigin />
  <link rel="preload" href="data/grid_preset.json" as="fetch" crossorigin />

  <!-- Preload shiny effect assets -->
  <link rel="preload" href="assets/effects/ShinySparkle.gif" as="image" />
  <link rel="preload" href="assets/effects/ShinySound.mp3" as="audio" />

  <style>
    :root{
      --stageH: min(920px, calc(100vh - 44px));
      --stageW: min(1220px, calc(100vw - 420px));

      --labelW: 210px;
      --headerH: 96px;
      --gap: 12px;

      --bg1:#050712;
      --bg2:#0B1433;
      --bg3:#081B1D;

      --line:rgba(255,255,255,.12);
      --text:#ECF1FF;
      --muted:#A9B4D6;

      --sel: rgba(120,180,255,.22);
      --mark: rgba(255,255,255,.08);
      --danger: rgba(255,110,110,.18);

      --shadow: 0 20px 80px rgba(0,0,0,.55);
    }

    *{ box-sizing:border-box; }
    html, body { height:100%; }
    body{
      margin:0;
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;

      background:
        radial-gradient(1200px 900px at 18% 16%, rgba(120,180,255,.22), transparent 55%),
        radial-gradient(900px 700px at 78% 70%, rgba(120,255,210,.16), transparent 55%),
        radial-gradient(850px 600px at 80% 18%, rgba(250,140,255,.12), transparent 55%),
        radial-gradient(700px 560px at 15% 75%, rgba(255,210,120,.08), transparent 60%),
        linear-gradient(155deg, var(--bg1), var(--bg2) 55%, var(--bg3));
    }

    body:before{
      content:"";
      position:fixed; inset:0;
      background:
        repeating-linear-gradient(135deg, rgba(255,255,255,.045) 0 1px, transparent 1px 16px),
        repeating-linear-gradient(45deg, rgba(255,255,255,.020) 0 1px, transparent 1px 22px),
        radial-gradient(900px 900px at 10% 90%, rgba(255,255,255,.06), transparent 62%),
        radial-gradient(800px 800px at 92% 10%, rgba(255,255,255,.05), transparent 62%);
      opacity:.55;
      pointer-events:none;
      mix-blend-mode: overlay;
    }

    body:after{
      content:"";
      position:fixed; inset:-90px;
      background:
        conic-gradient(from 220deg at 28% 32%, rgba(120,180,255,.12), transparent 35%, rgba(120,255,210,.10), transparent 70%, rgba(250,140,255,.10)),
        conic-gradient(from 60deg at 78% 58%, rgba(255,255,255,.06), transparent 45%, rgba(120,180,255,.07), transparent 78%),
        radial-gradient(900px 500px at 55% 90%, rgba(120,255,210,.08), transparent 65%);
      filter: blur(22px);
      opacity:.55;
      pointer-events:none;
    }

    #bgLayer{
      position: fixed;
      inset: 0;
      z-index: -5;
      pointer-events: none;
      background-position: center;
      background-repeat: no-repeat;
      background-size: cover;
      opacity: 0;
      transform: scale(1.03);
      transition: opacity .25s ease;
      mix-blend-mode: soft-light;
    }

    .wrap{
      display:grid;
      grid-template-columns: auto 340px;
      gap:18px;
      padding:22px;
      height:100%;
      align-items:start;
    }

    .stage{
      width: var(--stageW);
      height: var(--stageH);
      border:1px solid var(--line);
      border-radius:24px;
      background: rgba(0,0,0,.18);
      box-shadow: var(--shadow);
      padding:18px;
      overflow:hidden;
      position:relative;
      isolation:isolate;
    }

    .stage:before{
      content:"";
      position:absolute; inset:-2px;
      border-radius:24px;
      background:
        radial-gradient(900px 600px at 15% 25%, rgba(120,180,255,.12), transparent 62%),
        radial-gradient(760px 520px at 85% 70%, rgba(120,255,210,.10), transparent 62%),
        radial-gradient(650px 450px at 72% 18%, rgba(250,140,255,.09), transparent 62%),
        radial-gradient(600px 420px at 35% 70%, rgba(255,210,120,.06), transparent 65%);
      opacity:.95;
      pointer-events:none;
      z-index:0;
    }
    .stage:after{
      content:"";
      position:absolute; inset:-1px;
      border-radius:24px;
      background: linear-gradient(135deg, rgba(255,255,255,.12), transparent 35%, rgba(255,255,255,.07));
      pointer-events:none;
      opacity:.55;
      z-index:0;
    }

    .gridframe{
      position:relative;
      z-index:2;
      display:grid;
      grid-template-columns: var(--labelW) repeat(5, minmax(0, 1fr));
      grid-template-rows: var(--headerH) repeat(5, minmax(0, 1fr));
      gap: var(--gap);
      height:100%;
      width:100%;
      min-width:0;
      min-height:0;
    }

    /* Corner (oben links) als Scorebox */
    .cornerInfo{
      border-radius:18px;
      background: rgba(255,255,255,.055);
      border:1px solid rgba(255,255,255,.14);
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:flex-start;
      overflow:hidden;
      user-select:none;
    }
    .cornerTitle{
      font-weight:900;
      letter-spacing:1.2px;
      font-size:12px;
      color: rgba(255,255,255,.78);
      text-transform:uppercase;
    }
    .cornerValue{
      margin-top:6px;
      font-weight:950;
      font-size:28px;
      letter-spacing:.5px;
      color: rgba(255,255,255,.96);
      text-shadow: 0 10px 30px rgba(0,0,0,.45);
    }

    .hdr, .rowhdr{
      border-radius:18px;
      background: rgba(255,255,255,.065);
      border:1px solid rgba(255,255,255,.14);
      padding:10px 14px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      user-select:none;
      min-width:0;
      overflow:hidden;
      position:relative;
    }

    /* Header tooltip */
    #hdrTooltip{
      position:fixed;
      z-index:800;
      max-width:220px;
      padding:8px 12px;
      border-radius:12px;
      background: rgba(12,14,22,.94);
      border:1px solid rgba(255,255,255,.18);
      box-shadow: 0 12px 32px rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,.92);
      font-size:13px;
      font-weight:700;
      letter-spacing:.5px;
      text-transform:uppercase;
      line-height:1.3;
      pointer-events:none;
      opacity:0;
      transition: opacity .15s ease;
      word-break: break-word;
    }
    #hdrTooltip.visible{ opacity:1; }

    /* Desktop: show on hover */
    @media (hover:hover){
      .hdr:hover #hdrTooltip,
      .rowhdr:hover #hdrTooltip{ /* handled via JS positioning */ }
    }

    .hdrText, .rowhdrText{
      width:100%;
      max-width:100%;
      min-width:0;

      text-transform:uppercase;
      letter-spacing:1.4px;
      font-weight:900;
      font-size:18px;
      line-height:1.08;

      white-space:normal;
      overflow:hidden;

      display:-webkit-box;
      -webkit-box-orient: vertical;

      word-break: break-word;
      overflow-wrap: anywhere;
    }

    /* Column headers: limited height, clamp to 3 lines */
    .hdrText{
      -webkit-line-clamp: 3;
    }

    /* Row headers: more vertical space, allow up to 6 lines */
    .rowhdrText{
      -webkit-line-clamp: 6;
    }

    .hdrText[contenteditable="true"],
    .rowhdrText[contenteditable="true"]{
      outline: 2px solid rgba(120,180,255,.38);
      border-radius:10px;
      padding:4px 6px;
      background: rgba(255,255,255,.08);
    }

    .cell{
      border-radius:20px;
      background: rgba(255,255,255,.045);
      border:1px solid rgba(255,255,255,.11);
      position:relative;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      transition: background .15s ease, border-color .15s ease;
      min-width:0;
      min-height:0;
    }
    .cell:hover{ border-color: rgba(255,255,255,.18); }
    .cell.marked{
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.22);
      box-shadow: 0 0 0 2px rgba(255,255,255,.06) inset;
    }
    .cell.selected{
      background: rgba(120,180,255,.22);
      border-color: rgba(120,180,255,.42);
      box-shadow: 0 0 0 2px rgba(120,180,255,.16) inset;
    }
    .cell.delete-mode{ border-color: rgba(255,110,110,.28); }

    /* Community Overlay */
    .cell.comm-hit::before{
      content:"";
      position:absolute;
      inset:0;
      background: rgba(120, 180, 255, var(--commAlpha, 0));
      pointer-events:none;
      z-index:1;
    }

    /* Badge + Tooltip wrapper */
    .commBadgeWrap{
      position:absolute;
      top:8px;
      right:8px;
      z-index:8;
    }

    .commBadge{
      padding:4px 7px;
      border-radius:999px;
      font-weight:900;
      font-size:12px;
      line-height:1;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(255,255,255,.18);
      color: rgba(255,255,255,.95);
      user-select:none;
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 22px rgba(0,0,0,.35);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:24px;
    }

    /* Community tooltip (rendered as fixed overlay to avoid cell overflow clip) */
    #commTooltip{
      position:fixed;
      z-index:800;
      width: max-content;
      max-width: 220px;
      padding:10px 10px;
      border-radius:14px;
      background: rgba(12,14,22,.94);
      border: 1px solid rgba(255,255,255,.18);
      box-shadow: 0 18px 40px rgba(0,0,0,.55);
      backdrop-filter: blur(8px);
      color: rgba(255,255,255,.94);
      font-size:12px;
      line-height:1.25;
      letter-spacing:.2px;
      pointer-events:none;
      opacity:0;
      transition: opacity .15s ease;
    }
    #commTooltip.visible{ opacity:1; }

    #commTooltip .tTitle{
      font-weight:900;
      text-transform:uppercase;
      letter-spacing:1.1px;
      color: rgba(255,255,255,.72);
      font-size:10px;
      margin-bottom:6px;
    }

    #commTooltip .tList{
      white-space:pre-line;
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    /* Hide the inline .commTip (kept in DOM for data, but never shown) */
    .commTip{ display:none !important; }

    .cell img{
      width: 98%;
      height: 98%;
      object-fit: contain;
      filter: drop-shadow(0 12px 18px rgba(0,0,0,.42));
      transform: scale(1.08);
      z-index:2;
    }

    .cell .hint{
      color: rgba(255,255,255,.28);
      font-weight:800;
      letter-spacing:.8px;
      font-size:12px;
      text-transform:uppercase;
      user-select:none;
      z-index:2;
    }

    /* Shiny Sparkle Overlay (einmal abspielen) */
    .sparkle{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index:5; /* über Bild */
    }
    .sparkle img{
      width: 120%;
      height: 120%;
      object-fit: contain;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
    }

    .panel{
      border:1px solid var(--line);
      border-radius:24px;
      background: rgba(0,0,0,.18);
      box-shadow: var(--shadow);
      padding:16px;
      position:relative;
      height: fit-content;
      overflow: visible;
      isolation:isolate;
    }
    .panel:after{
      content:"";
      position:absolute; inset:-1px;
      border-radius:24px;
      background: linear-gradient(135deg, rgba(255,255,255,.10), transparent 35%, rgba(255,255,255,.06));
      pointer-events:none;
      opacity:.55;
      z-index:0;
    }

    .panel h2{
      margin:0 0 10px 0;
      font-size:16px;
      letter-spacing:.6px;
      position:relative;
      z-index:1;
    }
    .btn{
      width:100%;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.07);
      color:var(--text);
      padding:12px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:800;
      letter-spacing:.3px;
      position:relative;
      z-index:1;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn.danger{
      background: rgba(255,110,110,.18);
      border-color: rgba(255,110,110,.25);
    }
    .btn.danger:hover{ background: rgba(255,110,110,.22); }
    .btn.secondary{
      background: rgba(120,180,255,.11);
      border-color: rgba(120,180,255,.22);
    }
    .btn.secondary:hover{ background: rgba(120,180,255,.15); }
    .btn.small{
      padding:10px 12px;
      font-weight:800;
      font-size:14px;
    }

    .stack{ display:grid; gap:10px; position:relative; z-index:1; }
    .field{ position:relative; z-index:2; }
    input{
      width:100%;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.07);
      color:var(--text);
      padding:12px 12px;
      border-radius:14px;
      outline:none;
      font-size:15px;
      position:relative;
      z-index:2;
    }
    input:focus{
      border-color: rgba(120,180,255,.35);
      box-shadow: 0 0 0 3px rgba(120,180,255,.12);
    }
    .muted{ color:var(--muted); font-size:12px; line-height:1.35; position:relative; z-index:1; }
    .toast{ min-height:18px; color:var(--muted); font-size:13px; position:relative; z-index:1; }

    .dd{
      position:absolute;
      left:0; right:0;
      top:48px;
      background: rgba(16,18,30,.98);
      border:1px solid rgba(255,255,255,.18);
      border-radius:14px;
      overflow:hidden;
      max-height:260px;
      display:none;
      backdrop-filter: blur(8px);
      z-index:50;
      box-shadow: 0 18px 40px rgba(0,0,0,.55);
    }
    .dd.show{ display:block; }
    .dd button{
      width:100%;
      text-align:left;
      padding:10px 12px;
      border:0;
      background: transparent;
      color: var(--text);
      cursor:pointer;
      font-size:14px;
    }
    .dd button:hover, .dd button.active{
      background: rgba(120,180,255,.16);
    }

    /* Range (Lautstärke) */
    input[type="range"]{
      width:100%;
      accent-color: rgba(120,180,255,.95);
      height: 20px;
    }

    .presenter .panel{ display:none !important; }
    .presenter .wrap{ grid-template-columns: 1fr; }
    .presenter .stage{
      width: min(1220px, calc(100vw - 44px));
    }

    /* ===== Floating menu button (mobile only) ===== */
    #menuFab{
      display:none;
      position:fixed;
      bottom:18px;
      right:18px;
      z-index:900;
      width:52px; height:52px;
      border-radius:50%;
      border:1px solid rgba(255,255,255,.22);
      background: rgba(12,14,22,.85);
      backdrop-filter: blur(10px);
      color:#fff;
      font-size:24px;
      cursor:pointer;
      box-shadow: 0 8px 28px rgba(0,0,0,.5);
      align-items:center;
      justify-content:center;
    }

    /* ===== Bottom-sheet panel overlay (mobile) ===== */
    #panelBackdrop{
      display:none;
      position:fixed;
      inset:0;
      z-index:999;
      background: rgba(0,0,0,.5);
    }

    /* ===== Mobile layout (portrait + landscape phones) ===== */
    /* Portrait phones, or landscape with small height (phones rotated) */
    @media (max-width: 800px), (max-height: 500px) and (orientation: landscape){
      body{ overflow:hidden; }

      #menuFab{ display:flex; }

      .wrap{
        grid-template-columns: 1fr;
        padding: 0;
        height: 100%;
        gap: 0;
      }

      .stage{
        width: 100vw;
        height: 100vh;
        height: 100dvh;
        border: none;
        border-radius: 0;
        padding: 8px;
        box-shadow: none;
      }

      .gridframe{
        --labelW: clamp(48px, min(14vw, 18vh), 90px);
        --headerH: clamp(28px, min(10vw, 12vh), 64px);
        --gap: clamp(3px, min(1vw, 1vh), 8px);
      }

      .hdrText, .rowhdrText{
        font-size: clamp(8px, min(2.4vw, 3vh), 14px);
        letter-spacing: .3px;
      }
      .hdrText{ -webkit-line-clamp: 4; }
      .rowhdrText{ -webkit-line-clamp: 10; }

      .cornerInfo{ padding: 4px 6px; border-radius: 10px; }
      .cornerTitle{ font-size: clamp(6px, min(1.8vw, 2.2vh), 10px); }
      .cornerValue{ font-size: clamp(12px, min(3.5vw, 4.5vh), 22px); margin-top: 1px; }

      .cell{ border-radius: 12px; }
      .cell .hint{ font-size: clamp(6px, min(1.6vw, 2vh), 10px); }
      .hdr, .rowhdr{ border-radius: 10px; padding: 4px 6px; }

      /* Panel becomes bottom-sheet overlay */
      .panel{
        display: none;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        max-height: 70vh;
        max-height: 70dvh;
        overflow-y: auto;
        border-radius: 20px 20px 0 0;
        border-bottom: none;
        padding: 12px 16px 24px;
        background: rgba(8,10,20,.96);
        backdrop-filter: blur(16px);
        box-shadow: 0 -12px 40px rgba(0,0,0,.6);
        animation: sheetUp .25s ease-out;
      }
      .panel.open{ display: block; }

      @keyframes sheetUp{
        from{ transform: translateY(100%); }
        to{ transform: translateY(0); }
      }

      /* Drag handle visual */
      .panel.open::before{
        content: '';
        display: block;
        width: 40px;
        height: 4px;
        border-radius: 4px;
        background: rgba(255,255,255,.25);
        margin: 0 auto 10px;
      }

      /* Close button inside panel */
      #panelClose{
        display: block;
        position: absolute;
        top: 12px;
        right: 14px;
        z-index: 10;
        width: 32px; height: 32px;
        border: 1px solid rgba(255,255,255,.18);
        border-radius: 50%;
        background: rgba(255,255,255,.08);
        color: #fff;
        font-size: 18px;
        cursor: pointer;
        line-height: 1;
      }

      #panelBackdrop.open{ display: block; }

      /* Presenter mode on mobile */
      .presenter #menuFab{ display: none; }
      .presenter .stage{
        width: 100vw;
        height: 100vh;
        height: 100dvh;
      }
    }

    /* Landscape-specific tweaks: tighter vertical spacing */
    @media (max-height: 500px) and (orientation: landscape){
      .gridframe{
        --labelW: clamp(48px, 12vw, 110px);
        --headerH: clamp(24px, 10vh, 50px);
        --gap: clamp(2px, 0.8vh, 6px);
      }
      .hdrText{ -webkit-line-clamp: 2; }
      .rowhdrText{ -webkit-line-clamp: 4; }
      .stage{ padding: 4px 8px; }
      .cell{ border-radius: 8px; }
      .hdr, .rowhdr{ border-radius: 8px; padding: 2px 4px; }
      .cornerInfo{ padding: 2px 4px; border-radius: 8px; }
    }

    /* Hide mobile-only elements on desktop */
    @media (min-width: 801px) and (min-height: 501px){
      #panelClose{ display: none; }
    }

    /* Loading overlay */
    #loadingOverlay{
      position:fixed;
      inset:0;
      z-index:9999;
      background: rgba(5,7,18,.92);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:16px;
      transition: opacity .4s ease;
    }
    #loadingOverlay.hidden{
      opacity:0;
      pointer-events:none;
    }
    #loadingOverlay .loadTitle{
      font-weight:900;
      font-size:24px;
      letter-spacing:1.5px;
      color: rgba(255,255,255,.9);
    }
    #loadingOverlay .loadSub{
      font-size:14px;
      color: rgba(255,255,255,.5);
      letter-spacing:.3px;
    }
    @keyframes loadPulse{
      0%,100%{ opacity:.4; }
      50%{ opacity:1; }
    }
    #loadingOverlay .loadDots{
      animation: loadPulse 1.2s ease-in-out infinite;
    }
  </style>
</head>

<body>
  <div id="loadingOverlay">
    <div class="loadTitle">PokéGrid</div>
    <div class="loadSub loadDots">Daten werden geladen...</div>
  </div>

  <div id="hdrTooltip"></div>
  <div id="commTooltip"><div class="tTitle"></div><div class="tList"></div></div>
  <div id="bgLayer"></div>

  <div class="wrap">
    <div class="stage">
      <div class="gridframe">
        <div class="cornerInfo">
          <div class="cornerTitle">Communityscore</div>
          <div class="cornerValue" id="cornerScore">0</div>
        </div>

        <div class="hdr"><span class="hdrText">SPALTE 1</span></div>
        <div class="hdr"><span class="hdrText">SPALTE 2</span></div>
        <div class="hdr"><span class="hdrText">SPALTE 3</span></div>
        <div class="hdr"><span class="hdrText">SPALTE 4</span></div>
        <div class="hdr"><span class="hdrText">SPALTE 5</span></div>

        <div class="rowhdr"><span class="rowhdrText">ZEILE 1</span></div>
        <div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div>

        <div class="rowhdr"><span class="rowhdrText">ZEILE 2</span></div>
        <div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div>

        <div class="rowhdr"><span class="rowhdrText">ZEILE 3</span></div>
        <div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div>

        <div class="rowhdr"><span class="rowhdrText">ZEILE 4</span></div>
        <div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div>

        <div class="rowhdr"><span class="rowhdrText">ZEILE 5</span></div>
        <div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div><div class="cell"><div class="hint">leer</div></div>
      </div>
    </div>

    <div id="panelBackdrop"></div>
    <button id="menuFab" type="button" aria-label="Menu">&#9776;</button>

    <div class="panel" id="panel">
      <button id="panelClose" type="button" aria-label="Close">&times;</button>
      <h2>Controls</h2>
      <div class="stack">
        <div class="muted" id="autoStatus">Laden...</div>
        <div class="muted" id="commStatus">Community-Datensätze: 0</div>

        <div class="field">
          <input id="pokeInput" placeholder="Pokémon eingeben (Deutsch)…" autocomplete="off" disabled />
          <div class="dd" id="dd"></div>
        </div>

        <button class="btn" id="randomBtn">Zufälliges leeres Feld</button>
        <button class="btn danger" id="deleteBtn">Löschen</button>
        <button class="btn danger" id="resetBtn">Reset (Zellen leeren)</button>

        <button class="btn secondary" id="importPresetBtn">Grid-Preset importieren</button>
        <button class="btn secondary" id="exportBtn">Export (meine Lösung)</button>
        <button class="btn secondary" id="importCommBtn">Import Community (additiv)</button>
        <button class="btn small" id="clearCommBtn">Community löschen</button>

        <button class="btn" id="presenterBtn">Presenter Mode (H)</button>

        <div class="muted">Cry-Lautstärke</div>
        <input id="cryVol" type="range" min="0" max="100" value="25" />

        <div class="muted">Shiny-Lautstärke</div>
        <input id="shinyVol" type="range" min="0" max="100" value="55" />

        <div class="toast" id="toast"></div>
      </div>
    </div>
  </div>

  <script>
    // ========= CONFIG =========
    const MAX_COL_HEADER_LINES_DESKTOP = 3;
    const MAX_ROW_HEADER_LINES_DESKTOP = 6;
    const MAX_COL_HEADER_LINES_MOBILE = 4;
    const MAX_ROW_HEADER_LINES_MOBILE = 10;

    // Asset paths (relative to site root)
    const POKEMON_PATH = 'pokemon';
    const SHINY_PATH   = 'pokemon/shiny';
    const CRIES_PATH   = 'cries';
    const DATA_PATH    = 'data';
    const EFFECTS_PATH = 'assets/effects';

    const CRY_EXT = '.ogg';

    // Shiny (nur visuell, nicht exportiert)
    const SHINY_CHANCE = 0.05; // 5%
    const SPARKLE_DURATION_MS = 1000; // GIF ~1s

    // Lautstärke-Storage Keys
    const LS_CRY_VOL = 'pokegrid_cry_vol';
    const LS_SHINY_VOL = 'pokegrid_shiny_vol';

    // ========= State =========
    let dex = [];
    let appReady = false;

    let selectedCell = null;
    let deleteMode = false;
    let presenter = false;

    // Community aggregation
    let communityDatasetCount = 0;
    const communityCounts = new Map(); // key: "r,c,pokeKey" => count
    const communityNames = new Map();  // key: "r,c,pokeKey" => Set(personName)
    let communityMaxCount = 0;

    // Shiny assets (static URLs)
    const shinyGifUrl = `${EFFECTS_PATH}/ShinySparkle.gif`;
    const shinySoundUrl = `${EFFECTS_PATH}/ShinySound.mp3`;
    let shinyAudio = null;

    // Cry audio
    const cryAudio = new Audio();

    const toastEl = document.getElementById('toast');
    const autoStatus = document.getElementById('autoStatus');
    const commStatus = document.getElementById('commStatus');
    const scoreEl = document.getElementById('cornerScore');

    const cells = Array.from(document.querySelectorAll('.cell'));
    const headerSpans = Array.from(document.querySelectorAll('.hdrText, .rowhdrText'));
    const input = document.getElementById('pokeInput');
    const dd = document.getElementById('dd');
    const bgLayer = document.getElementById('bgLayer');

    // Lautstärke-UI
    const cryVolEl = document.getElementById('cryVol');
    const shinyVolEl = document.getElementById('shinyVol');

    function toast(msg){
      toastEl.textContent = msg || '';
      if (msg) setTimeout(() => { if (toastEl.textContent === msg) toastEl.textContent=''; }, 2400);
    }
    function setStatus(text){ autoStatus.textContent = text; }
    function setCommStatus(){ commStatus.textContent = `Community-Datensätze: ${communityDatasetCount}`; }

    function clamp01(v){ return Math.max(0, Math.min(1, v)); }

    function loadVolumePrefs(){
      const c = localStorage.getItem(LS_CRY_VOL);
      const s = localStorage.getItem(LS_SHINY_VOL);
      if (c != null && cryVolEl) cryVolEl.value = String(Math.max(0, Math.min(100, Number(c))));
      if (s != null && shinyVolEl) shinyVolEl.value = String(Math.max(0, Math.min(100, Number(s))));
    }

    function applyCryVolume(){
      const v = clamp01(Number(cryVolEl?.value ?? 25) / 100);
      cryAudio.volume = v;
      localStorage.setItem(LS_CRY_VOL, String(Math.round(v * 100)));
    }

    function applyShinyVolume(){
      const v = clamp01(Number(shinyVolEl?.value ?? 55) / 100);
      if (shinyAudio) shinyAudio.volume = v;
      localStorage.setItem(LS_SHINY_VOL, String(Math.round(v * 100)));
    }

    loadVolumePrefs();
    applyCryVolume();

    cryVolEl?.addEventListener('input', applyCryVolume);
    shinyVolEl?.addEventListener('input', applyShinyVolume);

    // ========= LocalStorage Grid Persistence =========
    const LS_GRID_STATE = 'pokegrid_grid_state';

    function saveGridState(){
      try {
        const cellData = cells.map(c => ({
          pid: c.dataset.pid || '',
          pokeKey: c.dataset.pokeKey || ''
        }));

        const colTexts = Array.from(document.querySelectorAll('.hdr .hdrText')).map(s => s.textContent);
        const rowTexts = Array.from(document.querySelectorAll('.rowhdr .rowhdrText')).map(s => s.textContent);

        const state = {
          cells: cellData,
          columns: colTexts,
          rows: rowTexts,
          timestamp: Date.now()
        };
        localStorage.setItem(LS_GRID_STATE, JSON.stringify(state));
      } catch(e) { console.warn('Speichern fehlgeschlagen:', e); }
    }

    function restoreGridState(){
      try {
        const raw = localStorage.getItem(LS_GRID_STATE);
        if (!raw) return false;

        const state = JSON.parse(raw);
        if (!state || !Array.isArray(state.cells)) return false;

        let restored = 0;
        for (let i = 0; i < Math.min(cells.length, state.cells.length); i++){
          const { pid, pokeKey } = state.cells[i];
          if (!pid || !pokeKey) continue;

          cells[i].dataset.pid = pid;
          cells[i].dataset.pokeKey = pokeKey;
          cells[i].innerHTML = '';

          const img = document.createElement('img');
          img.alt = pokeKey;
          img.loading = 'lazy';
          img.src = getImageUrl(pid, false); // restore always uses normal sprite
          cells[i].appendChild(img);
          restored++;
        }

        // Restore header texts (only if not locked by preset)
        if (Array.isArray(state.columns)){
          const colSpans = Array.from(document.querySelectorAll('.hdr .hdrText'));
          for (let i = 0; i < Math.min(colSpans.length, state.columns.length); i++){
            colSpans[i].textContent = state.columns[i];
          }
        }
        if (Array.isArray(state.rows)){
          const rowSpans = Array.from(document.querySelectorAll('.rowhdr .rowhdrText'));
          for (let i = 0; i < Math.min(rowSpans.length, state.rows.length); i++){
            rowSpans[i].textContent = state.rows[i];
          }
        }

        requestAnimationFrame(() => headerSpans.forEach(sp => fitHeaderText(sp)));
        refreshAllCommunityOverlays();

        if (restored > 0) toast(`${restored} Zelle(n) wiederhergestellt.`);
        return restored > 0;
      } catch(e) {
        console.warn('Wiederherstellen fehlgeschlagen:', e);
        return false;
      }
    }

    // ========= Normalization =========
    function stripAccents(s){
      return s.replace(/ß/g,'ss').normalize('NFKD').replace(/[\u0300-\u036f]/g,'');
    }
    function normKey(s){
      s = (s||'').trim().toLowerCase();
      s = stripAccents(s);
      s = s.replace(/[’´`]/g,"'");
      s = s.replace(/[^a-z0-9\s\-']/g,' ');
      s = s.replace(/-/g,' ');
      s = s.replace(/\s+/g,' ').trim();
      return s;
    }

    // ========= Header fit via clone =========
    const measureEl = document.createElement('div');
    measureEl.style.position = 'fixed';
    measureEl.style.left = '-99999px';
    measureEl.style.top = '0';
    measureEl.style.visibility = 'hidden';
    measureEl.style.pointerEvents = 'none';
    measureEl.style.whiteSpace = 'normal';
    measureEl.style.wordBreak = 'break-word';
    measureEl.style.overflowWrap = 'anywhere';
    document.body.appendChild(measureEl);

    function linesIfRendered(span, fontSizePx){
      const parent = span.parentElement;
      const w = Math.max(20, parent.clientWidth - 28);

      const cs = getComputedStyle(span);
      measureEl.style.width = w + 'px';
      measureEl.style.fontFamily = cs.fontFamily;
      measureEl.style.fontWeight = cs.fontWeight;
      measureEl.style.letterSpacing = cs.letterSpacing;
      measureEl.style.textTransform = cs.textTransform;
      measureEl.style.fontSize = fontSizePx + 'px';
      measureEl.style.lineHeight = (fontSizePx * 1.08) + 'px';
      measureEl.textContent = span.textContent;

      void measureEl.offsetHeight;

      const lh = fontSizePx * 1.08;
      const h = measureEl.scrollHeight;
      return Math.round(h / lh);
    }

    function fitHeaderText(span, max=18, min=9){
      const isRow = span.classList.contains('rowhdrText');
      const mobile = isMobile();
      const maxLines = isRow
        ? (mobile ? MAX_ROW_HEADER_LINES_MOBILE : MAX_ROW_HEADER_LINES_DESKTOP)
        : (mobile ? MAX_COL_HEADER_LINES_MOBILE : MAX_COL_HEADER_LINES_DESKTOP);
      for (let s=max; s>=min; s--){
        span.style.fontSize = s + 'px';
        const lines = linesIfRendered(span, s);
        if (lines <= maxLines) break;
      }
    }

    // ========= Title Lock / Preset =========
    function setTitleLock(locked){
      const editable = !locked;
      headerSpans.forEach(sp => { sp.style.pointerEvents = editable ? 'auto' : 'none'; });
    }

    function applyPreset(preset){
      if (!preset) return;

      const cols = Array.isArray(preset.columns) ? preset.columns : [];
      const rows = Array.isArray(preset.rows) ? preset.rows : [];

      const colSpans = Array.from(document.querySelectorAll('.hdr .hdrText'));
      const rowSpans = Array.from(document.querySelectorAll('.rowhdr .rowhdrText'));

      for (let i=0; i<Math.min(5, colSpans.length, cols.length); i++){
        colSpans[i].textContent = cols[i] ?? colSpans[i].textContent;
      }
      for (let i=0; i<Math.min(5, rowSpans.length, rows.length); i++){
        rowSpans[i].textContent = rows[i] ?? rowSpans[i].textContent;
      }

      requestAnimationFrame(() => headerSpans.forEach(sp => fitHeaderText(sp)));

      if (typeof preset.lockTitles === 'boolean'){
        setTitleLock(preset.lockTitles);
      }
    }

    // ========= Inline header edit =========
    function startEditHeader(span){
      if (span.isContentEditable) return;
      span.dataset.prev = span.textContent;
      span.contentEditable = "true";
      span.focus();
      document.execCommand('selectAll', false, null);
    }
    function finishEditHeader(span){
      if (!span.isContentEditable) return;
      span.contentEditable = "false";
      span.textContent = (span.textContent || '').trim() || span.dataset.prev || '—';
      fitHeaderText(span);
      saveGridState();
    }
    function cancelEditHeader(span){
      if (!span.isContentEditable) return;
      span.textContent = span.dataset.prev || span.textContent;
      span.contentEditable = "false";
      fitHeaderText(span);
    }

    headerSpans.forEach(sp => {
      sp.addEventListener('click', (e) => { e.stopPropagation(); startEditHeader(sp); });
      sp.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') { e.preventDefault(); cancelEditHeader(sp); }
        if (e.key === 'Enter')  { e.preventDefault(); sp.blur(); }
      });
      sp.addEventListener('blur', () => finishEditHeader(sp));
    });

    document.querySelectorAll('.hdr, .rowhdr').forEach(box => {
      box.addEventListener('click', () => {
        const sp = box.querySelector('.hdrText, .rowhdrText');
        if (sp) startEditHeader(sp);
      });
    });

    // ========= Header Tooltips =========
    const hdrTooltip = document.getElementById('hdrTooltip');
    let tooltipTimer = null;

    function showTooltip(box, span){
      const text = span.textContent.trim();
      if (!text) return;
      hdrTooltip.textContent = text;

      const rect = box.getBoundingClientRect();
      const isCol = box.classList.contains('hdr');

      if (isCol){
        // Position below column header
        hdrTooltip.style.left = Math.max(4, rect.left + rect.width/2 - 110) + 'px';
        hdrTooltip.style.top = (rect.bottom + 6) + 'px';
      } else {
        // Position to the right of row header
        hdrTooltip.style.left = (rect.right + 6) + 'px';
        hdrTooltip.style.top = (rect.top + rect.height/2 - 16) + 'px';
      }

      hdrTooltip.classList.add('visible');
    }

    function hideTooltip(){
      hdrTooltip.classList.remove('visible');
      clearTimeout(tooltipTimer);
    }

    document.querySelectorAll('.hdr, .rowhdr').forEach(box => {
      const sp = box.querySelector('.hdrText, .rowhdrText');
      if (!sp) return;

      // Desktop: hover
      box.addEventListener('mouseenter', () => {
        tooltipTimer = setTimeout(() => showTooltip(box, sp), 300);
      });
      box.addEventListener('mouseleave', hideTooltip);

      // Mobile: touch
      box.addEventListener('touchstart', (e) => {
        // Don't show tooltip if editing
        if (sp.isContentEditable) return;
        e.preventDefault();
        showTooltip(box, sp);
      }, { passive: false });

      box.addEventListener('touchend', () => {
        tooltipTimer = setTimeout(hideTooltip, 1500);
      });
    });

    // Hide tooltip when tapping elsewhere
    document.addEventListener('touchstart', (e) => {
      if (!e.target.closest('.hdr, .rowhdr')) hideTooltip();
    });

    // ========= Cells =========
    function selectCell(cell){
      if (selectedCell) selectedCell.classList.remove('selected');
      selectedCell = cell;
      cell.classList.add('selected');
    }

    function clearCell(cell){
      cell.dataset.pid = '';
      cell.dataset.pokeKey = '';
      cell.innerHTML = '<div class="hint">leer</div>';
      updateCommunityOverlayForCell(cell);
      recalcCommunityScore();
      saveGridState();
    }

    function isEmpty(cell){ return !cell.dataset.pid; }

    cells.forEach((c, idx) => {
      c.dataset.idx = String(idx);
      c.addEventListener('click', () => {
        if (deleteMode){
          if (c.dataset.pid){
            clearCell(c);
            toast('Zelle geleert.');
          } else {
            toast('Zelle ist schon leer.');
          }
          return;
        }
        selectCell(c);
      });
    });

    function randomEmptyCell(){
      const empties = cells.filter(isEmpty);
      if (!empties.length){
        toast('Keine leeren Felder mehr.');
        return null;
      }
      const pick = empties[Math.floor(Math.random()*empties.length)];
      cells.forEach(c => c.classList.remove('marked'));
      pick.classList.add('marked');
      selectCell(pick);
      return pick;
    }

    function resetGrid(){
      cells.forEach(c => {
        c.classList.remove('marked','selected','delete-mode');
        c.dataset.pid = '';
        c.dataset.pokeKey = '';
        c.innerHTML = '<div class="hint">leer</div>';
        updateCommunityOverlayForCell(c);
      });
      deleteMode = false;
      document.getElementById('deleteBtn').textContent = 'Löschen';
      selectCell(cells[0]);
      randomEmptyCell();
      recalcCommunityScore();
      saveGridState();
      toast('Grid zurückgesetzt.');
    }

    // ========= Loading (HTTP fetch) =========
    async function loadMapping(){
      const resp = await fetch(`${DATA_PATH}/dex_de.json`);
      if (!resp.ok) throw new Error('Fehler beim Laden von dex_de.json');
      const obj = await resp.json();
      dex = Array.isArray(obj.entries) ? obj.entries : [];
      if (!dex.length) throw new Error('Mapping leer/ungültig.');
    }

    async function loadPreset(){
      try {
        const resp = await fetch(`${DATA_PATH}/grid_preset.json`);
        if (!resp.ok) return null;
        return await resp.json();
      } catch { return null; }
    }

    function initShinyAssets(){
      shinyAudio = new Audio(shinySoundUrl);
      applyShinyVolume();
    }

    async function initApp(){
      try {
        setStatus('Laden...');

        const [, preset] = await Promise.all([
          loadMapping(),
          loadPreset()
        ]);

        if (preset) applyPreset(preset);
        initShinyAssets();

        // Restore saved grid state from localStorage
        restoreGridState();

        appReady = true;
        input.disabled = false;
        setStatus(`Bereit (${dex.length} Einträge)`);

        // Hide loading overlay
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
          overlay.classList.add('hidden');
          setTimeout(() => overlay.remove(), 500);
        }

        toast('Tool ist bereit.');
      } catch(err) {
        console.error(err);
        setStatus('Fehler beim Laden der Daten.');

        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
          overlay.querySelector('.loadSub').textContent = 'Fehler beim Laden. Bitte Seite neu laden.';
          overlay.querySelector('.loadSub').classList.remove('loadDots');
        }

        toast('Laden fehlgeschlagen. Seite neu laden.');
      }
    }

    // ========= Images / Shiny =========
    function getImageUrl(id, wantShiny){
      const folder = wantShiny ? SHINY_PATH : POKEMON_PATH;
      return `${folder}/${id}.png`;
    }

    function playSparkleOnce(cell){
      if (!shinyGifUrl) return;

      const old = cell.querySelector('.sparkle');
      if (old) old.remove();

      const wrap = document.createElement('div');
      wrap.className = 'sparkle';

      const img = document.createElement('img');
      img.src = shinyGifUrl + `#t=${Date.now()}`; // damit es sicher neu startet
      img.alt = 'Shiny';

      wrap.appendChild(img);
      cell.appendChild(wrap);

      setTimeout(() => wrap.remove(), SPARKLE_DURATION_MS);
    }

    function playShinySoundAndThen(fnAfter){
      if (!shinyAudio){
        setTimeout(() => fnAfter?.(), SPARKLE_DURATION_MS);
        return;
      }

      try{
        shinyAudio.pause();
        shinyAudio.currentTime = 0;

        const onEnd = () => {
          shinyAudio.removeEventListener('ended', onEnd);
          fnAfter?.();
        };
        shinyAudio.addEventListener('ended', onEnd);

        const p = shinyAudio.play();
        if (p && typeof p.catch === 'function'){
          p.catch(() => {
            shinyAudio.removeEventListener('ended', onEnd);
            setTimeout(() => fnAfter?.(), SPARKLE_DURATION_MS);
          });
        }
      }catch{
        setTimeout(() => fnAfter?.(), SPARKLE_DURATION_MS);
      }
    }

    function getCryUrl(id){
      return `${CRIES_PATH}/${id}${CRY_EXT}`;
    }

    async function playCry(id){
      try{
        const url = getCryUrl(id);
        cryAudio.pause();
        cryAudio.currentTime = 0;
        cryAudio.src = url;
        applyCryVolume();
        await cryAudio.play();
      }catch{}
    }

    // ========= Community overlay helpers =========
    function idxToRC(idx){
      const i = Number(idx);
      return { r: Math.floor(i/5), c: i % 5 };
    }

    function overlayKey(r,c,pokeKey){
      return `${r},${c},${pokeKey}`;
    }

    function baseNameNoExt(filename){
      return String(filename || '')
        .split(/[\\/]/).pop()
        .replace(/\.json$/i,'')
        .trim();
    }

    function setOrUpdateBadge(cell, count, namesMultiline){
      const existingWrap = cell.querySelector('.commBadgeWrap');

      if (!count || count <= 0){
        if (existingWrap) existingWrap.remove();
        return;
      }

      const list = namesMultiline || '';

      if (existingWrap){
        const badge = existingWrap.querySelector('.commBadge');
        if (badge) badge.textContent = String(count);
        existingWrap.dataset.names = list;
        return;
      }

      const wrap = document.createElement('div');
      wrap.className = 'commBadgeWrap';
      wrap.dataset.names = list;

      const badge = document.createElement('div');
      badge.className = 'commBadge';
      badge.textContent = String(count);

      wrap.appendChild(badge);
      cell.appendChild(wrap);

      // Attach tooltip events
      attachBadgeTooltipEvents(wrap);
    }

    function updateCommunityOverlayForCell(cell){
      const pokeKey = cell.dataset.pokeKey || '';
      const idx = cell.dataset.idx;

      if (!pokeKey || idx == null){
        cell.classList.remove('comm-hit');
        cell.style.removeProperty('--commAlpha');
        setOrUpdateBadge(cell, 0, '');
        return;
      }

      const {r,c} = idxToRC(idx);
      const k = overlayKey(r,c,pokeKey);
      const count = communityCounts.get(k) || 0;

      if (count <= 0){
        cell.classList.remove('comm-hit');
        cell.style.removeProperty('--commAlpha');
        setOrUpdateBadge(cell, 0, '');
        return;
      }

      const max = Math.max(1, communityMaxCount);
      const t = Math.min(1, count / max);
      const alpha = 0.06 + t * 0.16;

      cell.classList.add('comm-hit');
      cell.style.setProperty('--commAlpha', String(alpha));

      const set = communityNames.get(k);
      const namesMultiline = set && set.size
        ? [...set].sort((a,b)=>a.localeCompare(b)).join('\n')
        : '';

      setOrUpdateBadge(cell, count, namesMultiline);
    }

    function refreshAllCommunityOverlays(){
      cells.forEach(c => updateCommunityOverlayForCell(c));
      recalcCommunityScore();
    }

    function recalcCommunityScore(){
      let score = 0;
      for (const cell of cells){
        const pokeKey = cell.dataset.pokeKey || '';
        const idx = cell.dataset.idx;
        if (!pokeKey || idx == null) continue;

        const {r,c} = idxToRC(idx);
        const k = overlayKey(r,c,pokeKey);
        const count = communityCounts.get(k) || 0;

        if (count > 0) score += count; // Summe der Counts
      }
      if (scoreEl) scoreEl.textContent = String(score);
    }

    // ========= Community Badge Tooltip =========
    const commTooltip = document.getElementById('commTooltip');
    const commTipTitle = commTooltip.querySelector('.tTitle');
    const commTipList = commTooltip.querySelector('.tList');
    let commTipTimer = null;

    function showCommTooltip(wrap){
      const names = wrap.dataset.names || '';
      commTipTitle.textContent = 'Wer hatte das hier?';
      commTipList.textContent = names || '\u2014';

      const rect = wrap.getBoundingClientRect();

      // Position: try below the badge first, adjust if off-screen
      let top = rect.bottom + 8;
      let left = rect.left + rect.width / 2 - 110;

      // Clamp horizontal
      left = Math.max(6, Math.min(left, window.innerWidth - 226));

      // If below would go off-screen, show above
      commTooltip.style.left = left + 'px';
      commTooltip.style.top = top + 'px';
      commTooltip.classList.add('visible');

      // Check if it overflows bottom and flip above
      requestAnimationFrame(() => {
        const tipRect = commTooltip.getBoundingClientRect();
        if (tipRect.bottom > window.innerHeight - 6){
          commTooltip.style.top = (rect.top - tipRect.height - 8) + 'px';
        }
      });
    }

    function hideCommTooltip(){
      commTooltip.classList.remove('visible');
      clearTimeout(commTipTimer);
    }

    function attachBadgeTooltipEvents(wrap){
      // Desktop hover
      wrap.addEventListener('mouseenter', () => {
        commTipTimer = setTimeout(() => showCommTooltip(wrap), 200);
      });
      wrap.addEventListener('mouseleave', hideCommTooltip);

      // Mobile touch
      wrap.addEventListener('touchstart', (e) => {
        e.stopPropagation();
        showCommTooltip(wrap);
      }, { passive: true });
      wrap.addEventListener('touchend', () => {
        commTipTimer = setTimeout(hideCommTooltip, 2000);
      });
    }

    // Dismiss on tap elsewhere (mobile)
    document.addEventListener('touchstart', (e) => {
      if (!e.target.closest('.commBadgeWrap')) hideCommTooltip();
    });
    // Dismiss on scroll
    document.addEventListener('scroll', hideCommTooltip, true);

    // ========= Place Pokemon =========
    function placePokemon(entry){
      if (!entry) return;
      if (!selectedCell) randomEmptyCell();
      if (!selectedCell) return;

      const wantShiny = Math.random() < SHINY_CHANCE;
      const url = getImageUrl(entry.id, wantShiny);

      selectedCell.dataset.pid = String(entry.id);
      selectedCell.dataset.pokeKey = String(entry.key || normKey(entry.display || ''));

      selectedCell.innerHTML = '';

      const img = document.createElement('img');
      img.alt = entry.display;
      img.loading = 'lazy';
      img.src = url;
      selectedCell.appendChild(img);

      // Community overlay + Score
      updateCommunityOverlayForCell(selectedCell);
      recalcCommunityScore();
      saveGridState();

      // Audio: normal => Cry sofort
      // Shiny => Sparkle + Sound, DANACH Cry
      if (wantShiny){
        playSparkleOnce(selectedCell);
        playShinySoundAndThen(() => playCry(entry.id));
        toast(`Gesetzt: ${entry.display} (SHINY!)`);
      } else {
        playCry(entry.id);
        toast(`Gesetzt: ${entry.display}`);
      }
    }

    // ========= Autocomplete =========
    let ddIndex = -1;
    function hideDD(){ dd.classList.remove('show'); dd.innerHTML=''; ddIndex=-1; }
    function showDD(items){
      dd.innerHTML = '';
      items.forEach((it, idx) => {
        const b = document.createElement('button');
        b.type = 'button';
        b.textContent = it.display;
        b.addEventListener('click', () => {
          hideDD();
          placePokemon(it);
          input.value = '';
          input.blur();
          if (isMobile()) closePanel();
        });
        if (idx === 0) b.classList.add('active');
        dd.appendChild(b);
      });
      dd.classList.add('show');
      ddIndex = 0;
    }

    function searchDex(q){
      q = normKey(q);
      if (!q || !dex.length) return [];
      const starts = [];
      const contains = [];
      for (const e of dex){
        const k = e.key || '';
        if (k.startsWith(q)) starts.push(e);
        else if (k.includes(q)) contains.push(e);
        if (starts.length + contains.length >= 24) break;
      }
      return starts.concat(contains).slice(0, 12);
    }

    input.addEventListener('input', () => {
      const items = searchDex(input.value);
      if (!items.length){ hideDD(); return; }
      showDD(items);
    });

    input.addEventListener('keydown', (e) => {
      if (!dd.classList.contains('show')){
        if (e.key === 'Enter'){
          const q = normKey(input.value);
          const exact = dex.find(x => (x.key||'') === q) || null;
          if (exact){
            placePokemon(exact);
            input.value = '';
            input.blur();
            if (isMobile()) closePanel();
          }
        }
        return;
      }

      const buttons = Array.from(dd.querySelectorAll('button'));
      if (e.key === 'ArrowDown'){
        e.preventDefault();
        ddIndex = Math.min(ddIndex+1, buttons.length-1);
      } else if (e.key === 'ArrowUp'){
        e.preventDefault();
        ddIndex = Math.max(ddIndex-1, 0);
      } else if (e.key === 'Enter'){
        e.preventDefault();
        buttons[ddIndex]?.click();
        return;
      } else if (e.key === 'Escape'){
        e.preventDefault();
        hideDD();
        return;
      }

      buttons.forEach(b => b.classList.remove('active'));
      buttons[ddIndex]?.classList.add('active');
      buttons[ddIndex]?.scrollIntoView({block:'nearest'});
    });

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.field')) hideDD();
    });

    // ========= (Background picker removed for hosted version) =========

    // ========= Export / Import Community =========
    function downloadJson(obj, filename){
      const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    function exportMySolution(){
      const cellsOut = [];
      cells.forEach((cell) => {
        const pid = cell.dataset.pid || '';
        const pokeKey = cell.dataset.pokeKey || '';
        if (!pid || !pokeKey) return;
        const idx = cell.dataset.idx;
        const {r,c} = idxToRC(idx);
        cellsOut.push({ r, c, id: Number(pid), key: pokeKey });
      });

      const presetCols = Array.from(document.querySelectorAll('.hdr .hdrText')).map(s => s.textContent);
      const presetRows = Array.from(document.querySelectorAll('.rowhdr .rowhdrText')).map(s => s.textContent);

      const payload = {
        version: 1,
        createdAt: new Date().toISOString(),
        gridSize: 5,
        columns: presetCols,
        rows: presetRows,
        cells: cellsOut
      };

      const stamp = new Date().toISOString().replace(/[:.]/g,'-');
      downloadJson(payload, `pokegrid_solution_${stamp}.json`);
      toast(`Export erstellt (${cellsOut.length} Zellen).`);
    }

    function addCommunityDataset(dataset, who){
      if (!dataset || !Array.isArray(dataset.cells)) return;

      for (const it of dataset.cells){
        if (typeof it !== 'object' || it == null) continue;
        const r = Number(it.r);
        const c = Number(it.c);
        const key = String(it.key || '').trim();
        if (!Number.isFinite(r) || !Number.isFinite(c) || !key) continue;
        if (r < 0 || r > 4 || c < 0 || c > 4) continue;

        const mapKey = overlayKey(r,c,key);
        const next = (communityCounts.get(mapKey) || 0) + 1;
        communityCounts.set(mapKey, next);
        communityMaxCount = Math.max(communityMaxCount, next);

        if (who){
          const set = communityNames.get(mapKey) || new Set();
          set.add(who);
          communityNames.set(mapKey, set);
        }
      }
    }

    function importCommunityAdditive(){
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.json';
      fileInput.multiple = true;
      fileInput.style.display = 'none';

      fileInput.addEventListener('change', async () => {
        try {
          let loaded = 0;
          for (const file of fileInput.files){
            const text = await file.text();
            const obj = JSON.parse(text);

            const who = baseNameNoExt(file.name);
            addCommunityDataset(obj, who);

            loaded++;
          }

          communityDatasetCount += loaded;
          setCommStatus();
          refreshAllCommunityOverlays();
          toast(`Community importiert: +${loaded} Datei(en).`);
        } catch(err) {
          console.error(err);
          toast('Fehler beim Importieren.');
        }
        fileInput.remove();
      });

      document.body.appendChild(fileInput);
      fileInput.click();
    }

    function clearCommunity(){
      communityDatasetCount = 0;
      communityCounts.clear();
      communityNames.clear();
      communityMaxCount = 0;
      setCommStatus();
      refreshAllCommunityOverlays();
      toast('Community-Daten gelöscht.');
    }

    // ========= Controls =========
    document.getElementById('randomBtn').addEventListener('click', () => randomEmptyCell());

    const deleteBtn = document.getElementById('deleteBtn');
    function setDeleteMode(on){
      deleteMode = on;
      deleteBtn.textContent = on ? 'Abbrechen' : 'Löschen';
      deleteBtn.classList.toggle('danger', !on);
      cells.forEach(c => c.classList.toggle('delete-mode', on));
      toast(on ? 'Löschmodus: Klicke Zellen zum Löschen.' : 'Löschmodus beendet.');
    }
    deleteBtn.addEventListener('click', () => setDeleteMode(!deleteMode));

    document.getElementById('resetBtn').addEventListener('click', () => {
      const ok = confirm('Wirklich alle Zellen leeren? (Titel bleiben)');
      if (ok) resetGrid();
    });

    document.getElementById('importPresetBtn').addEventListener('click', () => {
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.json';
      fileInput.style.display = 'none';

      fileInput.addEventListener('change', async () => {
        try {
          const file = fileInput.files[0];
          if (!file) return;
          const text = await file.text();
          const preset = JSON.parse(text);
          applyPreset(preset);
          resetGrid();
          saveGridState();
          toast('Grid-Preset geladen.');
        } catch(err) {
          console.error(err);
          toast('Fehler beim Laden des Presets.');
        }
        fileInput.remove();
      });

      document.body.appendChild(fileInput);
      fileInput.click();
    });

    document.getElementById('exportBtn').addEventListener('click', exportMySolution);
    document.getElementById('importCommBtn').addEventListener('click', importCommunityAdditive);
    document.getElementById('clearCommBtn').addEventListener('click', () => {
      const ok = confirm('Community-Daten wirklich löschen?');
      if (ok) clearCommunity();
    });

    const presenterBtn = document.getElementById('presenterBtn');
    function togglePresenter(){
      presenter = !presenter;
      document.body.classList.toggle('presenter', presenter);
      if (presenter) closePanel();
      toast(presenter ? 'Presenter Mode: nur Grid.' : 'Presenter Mode aus.');
    }
    presenterBtn.addEventListener('click', togglePresenter);

    document.addEventListener('keydown', (e) => {
      if (e.target.matches('input,[contenteditable="true"]')) return;
      if (e.key.toLowerCase() === 'r') randomEmptyCell();
      if (e.key.toLowerCase() === 'd') setDeleteMode(!deleteMode);
      if (e.key.toLowerCase() === 'h') togglePresenter();
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedCell && selectedCell.dataset.pid){
        e.preventDefault();
        clearCell(selectedCell);
        toast('Zelle geleert.');
      }
    });

    // ========= Mobile Panel (bottom-sheet) =========
    const panelEl = document.getElementById('panel');
    const panelBackdrop = document.getElementById('panelBackdrop');
    const menuFab = document.getElementById('menuFab');
    const panelClose = document.getElementById('panelClose');

    function isMobile(){
      return window.matchMedia('(max-width:800px)').matches
          || window.matchMedia('(max-height:500px) and (orientation:landscape)').matches;
    }

    function openPanel(focusInput){
      panelEl.classList.add('open');
      panelBackdrop.classList.add('open');
      // On iOS, focus() must happen synchronously within the user gesture
      // call stack — any setTimeout breaks the chain and the OS blocks the keyboard.
      if (focusInput) input.focus({ preventScroll: true });
    }
    function closePanel(){
      panelEl.classList.remove('open');
      panelBackdrop.classList.remove('open');
    }

    menuFab.addEventListener('click', (e) => {
      e.stopPropagation();
      openPanel(true);
    });
    panelClose.addEventListener('click', closePanel);
    panelBackdrop.addEventListener('click', closePanel);

    // Open panel when a cell is tapped on mobile
    cells.forEach(c => {
      c.addEventListener('click', () => {
        if (isMobile() && !deleteMode) openPanel(true);
      });
    });

    // ========= Init =========
    selectCell(cells[0]);
    randomEmptyCell();
    setCommStatus();
    recalcCommunityScore();

    requestAnimationFrame(() => headerSpans.forEach(sp => fitHeaderText(sp)));
    window.addEventListener('resize', () => headerSpans.forEach(sp => fitHeaderText(sp)));

    initApp();
  </script>
</body>
</html>
